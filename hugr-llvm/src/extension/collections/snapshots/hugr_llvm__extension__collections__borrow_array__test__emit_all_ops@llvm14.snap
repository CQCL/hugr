---
source: hugr-llvm/src/extension/collections/borrow_array.rs
expression: mod_str
---
; ModuleID = 'test_context'
source_filename = "test_context"

@0 = private unnamed_addr constant [34 x i8] c"Array element is already borrowed\00", align 1
@prelude.panic_template = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1
@1 = private unnamed_addr constant [37 x i8] c"Expected variant 1 but got variant 0\00", align 1
@prelude.panic_template.1 = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1
@2 = private unnamed_addr constant [37 x i8] c"Expected variant 1 but got variant 0\00", align 1
@prelude.panic_template.2 = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1
@3 = private unnamed_addr constant [37 x i8] c"Expected variant 1 but got variant 0\00", align 1
@prelude.panic_template.3 = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1
@4 = private unnamed_addr constant [37 x i8] c"Expected variant 1 but got variant 0\00", align 1
@prelude.panic_template.4 = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1
@5 = private unnamed_addr constant [37 x i8] c"Expected variant 1 but got variant 0\00", align 1
@prelude.panic_template.5 = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1

define private void @_hl.main.1() {
alloca_block:
  br label %entry_block

entry_block:                                      ; preds = %alloca_block
  %0 = call i8* @malloc(i64 mul (i64 ptrtoint (i64* getelementptr (i64, i64* null, i32 1) to i64), i64 2))
  %1 = bitcast i8* %0 to i64*
  %2 = call i8* @malloc(i64 ptrtoint (i64* getelementptr (i64, i64* null, i32 1) to i64))
  %3 = bitcast i8* %2 to i64*
  call void @llvm.memset.p0i64.i64(i64* %3, i8 0, i64 ptrtoint (i64* getelementptr (i64, i64* null, i32 1) to i64), i1 false)
  %4 = insertvalue { i64*, i64*, i64 } poison, i64* %1, 0
  %5 = insertvalue { i64*, i64*, i64 } %4, i64* %3, 1
  %6 = insertvalue { i64*, i64*, i64 } %5, i64 0, 2
  %7 = getelementptr inbounds i64, i64* %1, i64 0
  store i64 1, i64* %7, align 4
  %8 = getelementptr inbounds i64, i64* %1, i64 1
  store i64 2, i64* %8, align 4
  %9 = call i8* @malloc(i64 mul (i64 ptrtoint (i64* getelementptr (i64, i64* null, i32 1) to i64), i64 2))
  %10 = bitcast i8* %9 to i64*
  %11 = call i8* @malloc(i64 ptrtoint (i64* getelementptr (i64, i64* null, i32 1) to i64))
  %12 = bitcast i8* %11 to i64*
  call void @llvm.memset.p0i64.i64(i64* %12, i8 0, i64 ptrtoint (i64* getelementptr (i64, i64* null, i32 1) to i64), i1 false)
  %13 = insertvalue { i64*, i64*, i64 } poison, i64* %10, 0
  %14 = insertvalue { i64*, i64*, i64 } %13, i64* %12, 1
  %15 = insertvalue { i64*, i64*, i64 } %14, i64 0, 2
  %16 = getelementptr inbounds i64, i64* %10, i64 0
  store i64 1, i64* %16, align 4
  %17 = getelementptr inbounds i64, i64* %10, i64 1
  store i64 2, i64* %17, align 4
  %array_ptr = extractvalue { i64*, i64*, i64 } %15, 0
  %array_mask_ptr = extractvalue { i64*, i64*, i64 } %15, 1
  %array_offset = extractvalue { i64*, i64*, i64 } %15, 2
  %18 = add i64 %array_offset, 0
  call void @__barray_check_idx_not_borrowed(i64* %array_mask_ptr, i64 %18)
  %19 = getelementptr inbounds i64, i64* %array_ptr, i64 %18
  %20 = load i64, i64* %19, align 4
  %21 = add i64 %array_offset, 1
  call void @__barray_check_idx_not_borrowed(i64* %array_mask_ptr, i64 %21)
  %22 = getelementptr inbounds i64, i64* %array_ptr, i64 %21
  %23 = load i64, i64* %22, align 4
  %array_ptr9 = extractvalue { i64*, i64*, i64 } %6, 0
  %array_mask_ptr10 = extractvalue { i64*, i64*, i64 } %6, 1
  %array_offset11 = extractvalue { i64*, i64*, i64 } %6, 2
  %24 = icmp ult i64 0, 2
  %25 = icmp ult i64 1, 2
  %26 = and i1 %24, %25
  br i1 %26, label %29, label %27

27:                                               ; preds = %entry_block
  %28 = insertvalue { i1, { i64*, i64*, i64 } } { i1 false, { i64*, i64*, i64 } poison }, { i64*, i64*, i64 } %6, 1
  br label %37

29:                                               ; preds = %entry_block
  %30 = add i64 0, %array_offset11
  %31 = add i64 1, %array_offset11
  call void @__barray_check_idx_not_borrowed(i64* %array_mask_ptr10, i64 %30)
  call void @__barray_check_idx_not_borrowed(i64* %array_mask_ptr10, i64 %31)
  %32 = getelementptr inbounds i64, i64* %array_ptr9, i64 %30
  %33 = load i64, i64* %32, align 4
  %34 = getelementptr inbounds i64, i64* %array_ptr9, i64 %31
  %35 = load i64, i64* %34, align 4
  store i64 %35, i64* %32, align 4
  store i64 %33, i64* %34, align 4
  %36 = insertvalue { i1, { i64*, i64*, i64 } } { i1 true, { i64*, i64*, i64 } poison }, { i64*, i64*, i64 } %6, 1
  br label %37

37:                                               ; preds = %27, %29
  %"0.0" = phi { i1, { i64*, i64*, i64 } } [ %36, %29 ], [ %28, %27 ]
  %38 = extractvalue { i1, { i64*, i64*, i64 } } %"0.0", 0
  switch i1 %38, label %39 [
    i1 true, label %41
  ]

39:                                               ; preds = %37
  %40 = extractvalue { i1, { i64*, i64*, i64 } } %"0.0", 1
  br label %cond_19_case_0

41:                                               ; preds = %37
  %42 = extractvalue { i1, { i64*, i64*, i64 } } %"0.0", 1
  br label %cond_19_case_1

cond_19_case_0:                                   ; preds = %39
  %43 = extractvalue { i32, i8* } { i32 1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @1, i32 0, i32 0) }, 0
  %44 = extractvalue { i32, i8* } { i32 1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @1, i32 0, i32 0) }, 1
  %45 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @prelude.panic_template.1, i32 0, i32 0), i32 %43, i8* %44)
  call void @abort()
  br label %cond_exit_19

cond_19_case_1:                                   ; preds = %41
  br label %cond_exit_19

cond_exit_19:                                     ; preds = %cond_19_case_1, %cond_19_case_0
  %"014.0" = phi { i64*, i64*, i64 } [ zeroinitializer, %cond_19_case_0 ], [ %42, %cond_19_case_1 ]
  %array_ptr26 = extractvalue { i64*, i64*, i64 } %"014.0", 0
  %array_mask_ptr27 = extractvalue { i64*, i64*, i64 } %"014.0", 1
  %array_offset28 = extractvalue { i64*, i64*, i64 } %"014.0", 2
  %46 = icmp ult i64 0, 2
  br i1 %46, label %48, label %47

47:                                               ; preds = %cond_exit_19
  br label %53

48:                                               ; preds = %cond_exit_19
  %49 = add i64 0, %array_offset28
  call void @__barray_check_idx_not_borrowed(i64* %array_mask_ptr27, i64 %49)
  %50 = getelementptr inbounds i64, i64* %array_ptr26, i64 %49
  %51 = load i64, i64* %50, align 4
  %52 = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %51, 1
  br label %53

53:                                               ; preds = %47, %48
  %"029.0" = phi { i1, i64 } [ %52, %48 ], [ { i1 false, i64 poison }, %47 ]
  %54 = extractvalue { i1, i64 } %"029.0", 0
  switch i1 %54, label %55 [
    i1 true, label %56
  ]

55:                                               ; preds = %53
  br label %cond_31_case_0

56:                                               ; preds = %53
  %57 = extractvalue { i1, i64 } %"029.0", 1
  br label %cond_31_case_1

cond_31_case_0:                                   ; preds = %55
  %58 = extractvalue { i32, i8* } { i32 1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @2, i32 0, i32 0) }, 0
  %59 = extractvalue { i32, i8* } { i32 1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @2, i32 0, i32 0) }, 1
  %60 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @prelude.panic_template.2, i32 0, i32 0), i32 %58, i8* %59)
  call void @abort()
  br label %cond_exit_31

cond_31_case_1:                                   ; preds = %56
  br label %cond_exit_31

cond_exit_31:                                     ; preds = %cond_31_case_1, %cond_31_case_0
  %"033.0" = phi i64 [ 0, %cond_31_case_0 ], [ %57, %cond_31_case_1 ]
  %array_ptr43 = extractvalue { i64*, i64*, i64 } %"014.0", 0
  %array_mask_ptr44 = extractvalue { i64*, i64*, i64 } %"014.0", 1
  %array_offset45 = extractvalue { i64*, i64*, i64 } %"014.0", 2
  %61 = icmp ult i64 1, 2
  br i1 %61, label %65, label %62

62:                                               ; preds = %cond_exit_31
  %63 = insertvalue { i1, { i64*, i64*, i64 }, i64 } { i1 false, { i64*, i64*, i64 } poison, i64 poison }, i64 %"033.0", 2
  %64 = insertvalue { i1, { i64*, i64*, i64 }, i64 } %63, { i64*, i64*, i64 } %"014.0", 1
  br label %71

65:                                               ; preds = %cond_exit_31
  %66 = add i64 1, %array_offset45
  call void @__barray_check_idx_not_borrowed(i64* %array_mask_ptr44, i64 %66)
  %67 = getelementptr inbounds i64, i64* %array_ptr43, i64 %66
  %68 = load i64, i64* %67, align 4
  store i64 %"033.0", i64* %67, align 4
  %69 = insertvalue { i1, { i64*, i64*, i64 }, i64 } { i1 true, { i64*, i64*, i64 } poison, i64 poison }, i64 %68, 2
  %70 = insertvalue { i1, { i64*, i64*, i64 }, i64 } %69, { i64*, i64*, i64 } %"014.0", 1
  br label %71

71:                                               ; preds = %62, %65
  %"046.0" = phi { i1, { i64*, i64*, i64 }, i64 } [ %70, %65 ], [ %64, %62 ]
  %72 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %"046.0", 0
  switch i1 %72, label %73 [
    i1 true, label %76
  ]

73:                                               ; preds = %71
  %74 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %"046.0", 2
  %75 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %"046.0", 1
  br label %cond_42_case_0

76:                                               ; preds = %71
  %77 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %"046.0", 2
  %78 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %"046.0", 1
  br label %cond_42_case_1

cond_42_case_0:                                   ; preds = %73
  %79 = extractvalue { i32, i8* } { i32 1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @3, i32 0, i32 0) }, 0
  %80 = extractvalue { i32, i8* } { i32 1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @3, i32 0, i32 0) }, 1
  %81 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @prelude.panic_template.3, i32 0, i32 0), i32 %79, i8* %80)
  call void @abort()
  br label %cond_exit_42

cond_42_case_1:                                   ; preds = %76
  br label %cond_exit_42

cond_exit_42:                                     ; preds = %cond_42_case_1, %cond_42_case_0
  %"049.0" = phi i64 [ 0, %cond_42_case_0 ], [ %77, %cond_42_case_1 ]
  %"150.0" = phi { i64*, i64*, i64 } [ zeroinitializer, %cond_42_case_0 ], [ %78, %cond_42_case_1 ]
  %array_ptr69 = extractvalue { i64*, i64*, i64 } %"150.0", 0
  %array_mask_ptr70 = extractvalue { i64*, i64*, i64 } %"150.0", 1
  %array_offset71 = extractvalue { i64*, i64*, i64 } %"150.0", 2
  %new_offset = add i64 %array_offset71, 1
  call void @__barray_check_idx_not_borrowed(i64* %array_mask_ptr70, i64 %array_offset71)
  %82 = getelementptr inbounds i64, i64* %array_ptr69, i64 %array_offset71
  %83 = load i64, i64* %82, align 4
  %84 = insertvalue { i64*, i64*, i64 } poison, i64* %array_ptr69, 0
  %85 = insertvalue { i64*, i64*, i64 } %84, i64* %array_mask_ptr70, 1
  %86 = insertvalue { i64*, i64*, i64 } %85, i64 %new_offset, 2
  %87 = insertvalue { i1, { i64*, i64*, i64 }, i64 } { i1 true, { i64*, i64*, i64 } poison, i64 poison }, i64 %83, 2
  %88 = insertvalue { i1, { i64*, i64*, i64 }, i64 } %87, { i64*, i64*, i64 } %86, 1
  %89 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %88, 0
  switch i1 %89, label %90 [
    i1 true, label %91
  ]

90:                                               ; preds = %cond_exit_42
  br label %cond_53_case_0

91:                                               ; preds = %cond_exit_42
  %92 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %88, 2
  %93 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %88, 1
  br label %cond_53_case_1

cond_53_case_0:                                   ; preds = %90
  %94 = extractvalue { i32, i8* } { i32 1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @4, i32 0, i32 0) }, 0
  %95 = extractvalue { i32, i8* } { i32 1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @4, i32 0, i32 0) }, 1
  %96 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @prelude.panic_template.4, i32 0, i32 0), i32 %94, i8* %95)
  call void @abort()
  br label %cond_exit_53

cond_53_case_1:                                   ; preds = %91
  br label %cond_exit_53

cond_exit_53:                                     ; preds = %cond_53_case_1, %cond_53_case_0
  %"073.0" = phi i64 [ 0, %cond_53_case_0 ], [ %92, %cond_53_case_1 ]
  %"174.0" = phi { i64*, i64*, i64 } [ zeroinitializer, %cond_53_case_0 ], [ %93, %cond_53_case_1 ]
  %array_ptr87 = extractvalue { i64*, i64*, i64 } %"174.0", 0
  %array_mask_ptr88 = extractvalue { i64*, i64*, i64 } %"174.0", 1
  %array_offset89 = extractvalue { i64*, i64*, i64 } %"174.0", 2
  %97 = add i64 %array_offset89, 0
  call void @__barray_check_idx_not_borrowed(i64* %array_mask_ptr88, i64 %97)
  %98 = getelementptr inbounds i64, i64* %array_ptr87, i64 %97
  %99 = load i64, i64* %98, align 4
  %100 = insertvalue { i64*, i64*, i64 } poison, i64* %array_ptr87, 0
  %101 = insertvalue { i64*, i64*, i64 } %100, i64* %array_mask_ptr88, 1
  %102 = insertvalue { i64*, i64*, i64 } %101, i64 %array_offset89, 2
  %103 = insertvalue { i1, { i64*, i64*, i64 }, i64 } { i1 true, { i64*, i64*, i64 } poison, i64 poison }, i64 %99, 2
  %104 = insertvalue { i1, { i64*, i64*, i64 }, i64 } %103, { i64*, i64*, i64 } %102, 1
  %105 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %104, 0
  switch i1 %105, label %106 [
    i1 true, label %107
  ]

106:                                              ; preds = %cond_exit_53
  br label %cond_64_case_0

107:                                              ; preds = %cond_exit_53
  %108 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %104, 2
  %109 = extractvalue { i1, { i64*, i64*, i64 }, i64 } %104, 1
  br label %cond_64_case_1

cond_64_case_0:                                   ; preds = %106
  %110 = extractvalue { i32, i8* } { i32 1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @5, i32 0, i32 0) }, 0
  %111 = extractvalue { i32, i8* } { i32 1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @5, i32 0, i32 0) }, 1
  %112 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @prelude.panic_template.5, i32 0, i32 0), i32 %110, i8* %111)
  call void @abort()
  br label %cond_exit_64

cond_64_case_1:                                   ; preds = %107
  br label %cond_exit_64

cond_exit_64:                                     ; preds = %cond_64_case_1, %cond_64_case_0
  %"091.0" = phi i64 [ 0, %cond_64_case_0 ], [ %108, %cond_64_case_1 ]
  %"192.0" = phi { i64*, i64*, i64 } [ zeroinitializer, %cond_64_case_0 ], [ %109, %cond_64_case_1 ]
  %array_ptr105 = extractvalue { i64*, i64*, i64 } %"192.0", 0
  %array_mask_ptr106 = extractvalue { i64*, i64*, i64 } %"192.0", 1
  %array_offset107 = extractvalue { i64*, i64*, i64 } %"192.0", 2
  %113 = bitcast i64* %array_ptr105 to i8*
  call void @free(i8* %113)
  %114 = bitcast i64* %array_mask_ptr106 to i8*
  call void @free(i8* %114)
  ret void
}

declare i8* @malloc(i64)

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0i64.i64(i64* nocapture writeonly, i8, i64, i1 immarg) #0

define internal void @__barray_check_idx_not_borrowed(i64* %0, i64 %1) {
  %3 = udiv i64 %1, 64
  %4 = getelementptr inbounds i64, i64* %0, i64 %3
  %5 = load i64, i64* %4, align 4
  %6 = urem i64 %1, 64
  %7 = lshr i64 %5, %6
  %8 = trunc i64 %7 to i1
  br i1 %8, label %elem_borrowed, label %elem_free

elem_borrowed:                                    ; preds = %2
  %9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @prelude.panic_template, i32 0, i32 0), i32 2, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @0, i32 0, i32 0))
  call void @abort()
  unreachable

elem_free:                                        ; preds = %2
  ret void
}

declare i32 @printf(i8*, ...)

declare void @abort()

declare void @free(i8*)

attributes #0 = { argmemonly nofree nounwind willreturn writeonly }
