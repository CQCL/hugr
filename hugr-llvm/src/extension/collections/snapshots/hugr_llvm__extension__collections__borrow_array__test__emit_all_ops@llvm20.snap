---
source: hugr-llvm/src/extension/collections/borrow_array.rs
expression: mod_str
---
; ModuleID = 'test_context'
source_filename = "test_context"

@0 = private unnamed_addr constant [34 x i8] c"Array element is already borrowed\00", align 1
@prelude.panic_template = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1
@1 = private unnamed_addr constant [37 x i8] c"Expected variant 1 but got variant 0\00", align 1
@prelude.panic_template.1 = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1
@2 = private unnamed_addr constant [37 x i8] c"Expected variant 1 but got variant 0\00", align 1
@prelude.panic_template.2 = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1
@3 = private unnamed_addr constant [37 x i8] c"Expected variant 1 but got variant 0\00", align 1
@prelude.panic_template.3 = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1
@4 = private unnamed_addr constant [37 x i8] c"Expected variant 1 but got variant 0\00", align 1
@prelude.panic_template.4 = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1
@5 = private unnamed_addr constant [37 x i8] c"Expected variant 1 but got variant 0\00", align 1
@prelude.panic_template.5 = private unnamed_addr constant [34 x i8] c"Program panicked (signal %i): %s\0A\00", align 1

define private void @_hl.main.1() {
alloca_block:
  br label %entry_block

entry_block:                                      ; preds = %alloca_block
  %0 = call ptr @malloc(i64 mul (i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64), i64 2))
  %1 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64))
  call void @llvm.memset.p0.i64(ptr %1, i8 0, i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64), i1 false)
  %2 = insertvalue { ptr, ptr, i64 } poison, ptr %0, 0
  %3 = insertvalue { ptr, ptr, i64 } %2, ptr %1, 1
  %4 = insertvalue { ptr, ptr, i64 } %3, i64 0, 2
  %5 = getelementptr inbounds i64, ptr %0, i64 0
  store i64 1, ptr %5, align 4
  %6 = getelementptr inbounds i64, ptr %0, i64 1
  store i64 2, ptr %6, align 4
  %7 = call ptr @malloc(i64 mul (i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64), i64 2))
  %8 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64))
  call void @llvm.memset.p0.i64(ptr %8, i8 0, i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64), i1 false)
  %9 = insertvalue { ptr, ptr, i64 } poison, ptr %7, 0
  %10 = insertvalue { ptr, ptr, i64 } %9, ptr %8, 1
  %11 = insertvalue { ptr, ptr, i64 } %10, i64 0, 2
  %12 = getelementptr inbounds i64, ptr %7, i64 0
  store i64 1, ptr %12, align 4
  %13 = getelementptr inbounds i64, ptr %7, i64 1
  store i64 2, ptr %13, align 4
  %array_ptr = extractvalue { ptr, ptr, i64 } %11, 0
  %array_mask_ptr = extractvalue { ptr, ptr, i64 } %11, 1
  %array_offset = extractvalue { ptr, ptr, i64 } %11, 2
  %14 = add i64 %array_offset, 0
  call void @__barray_mask_check_not_borrowed(ptr %array_mask_ptr, i64 %14)
  %15 = getelementptr inbounds i64, ptr %array_ptr, i64 %14
  %16 = load i64, ptr %15, align 4
  %17 = add i64 %array_offset, 1
  call void @__barray_mask_check_not_borrowed(ptr %array_mask_ptr, i64 %17)
  %18 = getelementptr inbounds i64, ptr %array_ptr, i64 %17
  %19 = load i64, ptr %18, align 4
  %array_ptr9 = extractvalue { ptr, ptr, i64 } %4, 0
  %array_mask_ptr10 = extractvalue { ptr, ptr, i64 } %4, 1
  %array_offset11 = extractvalue { ptr, ptr, i64 } %4, 2
  %20 = icmp ult i64 0, 2
  %21 = icmp ult i64 1, 2
  %22 = and i1 %20, %21
  br i1 %22, label %25, label %23

23:                                               ; preds = %entry_block
  %24 = insertvalue { i1, { ptr, ptr, i64 } } { i1 false, { ptr, ptr, i64 } poison }, { ptr, ptr, i64 } %4, 1
  br label %33

25:                                               ; preds = %entry_block
  %26 = add i64 0, %array_offset11
  %27 = add i64 1, %array_offset11
  call void @__barray_mask_check_not_borrowed(ptr %array_mask_ptr10, i64 %26)
  call void @__barray_mask_check_not_borrowed(ptr %array_mask_ptr10, i64 %27)
  %28 = getelementptr inbounds i64, ptr %array_ptr9, i64 %26
  %29 = load i64, ptr %28, align 4
  %30 = getelementptr inbounds i64, ptr %array_ptr9, i64 %27
  %31 = load i64, ptr %30, align 4
  store i64 %31, ptr %28, align 4
  store i64 %29, ptr %30, align 4
  %32 = insertvalue { i1, { ptr, ptr, i64 } } { i1 true, { ptr, ptr, i64 } poison }, { ptr, ptr, i64 } %4, 1
  br label %33

33:                                               ; preds = %23, %25
  %"0.0" = phi { i1, { ptr, ptr, i64 } } [ %32, %25 ], [ %24, %23 ]
  %34 = extractvalue { i1, { ptr, ptr, i64 } } %"0.0", 0
  switch i1 %34, label %35 [
    i1 true, label %37
  ]

35:                                               ; preds = %33
  %36 = extractvalue { i1, { ptr, ptr, i64 } } %"0.0", 1
  br label %cond_19_case_0

37:                                               ; preds = %33
  %38 = extractvalue { i1, { ptr, ptr, i64 } } %"0.0", 1
  br label %cond_19_case_1

cond_19_case_0:                                   ; preds = %35
  %39 = extractvalue { i32, ptr } { i32 1, ptr @1 }, 0
  %40 = extractvalue { i32, ptr } { i32 1, ptr @1 }, 1
  %41 = call i32 (ptr, ...) @printf(ptr @prelude.panic_template.1, i32 %39, ptr %40)
  call void @abort()
  br label %cond_exit_19

cond_19_case_1:                                   ; preds = %37
  br label %cond_exit_19

cond_exit_19:                                     ; preds = %cond_19_case_1, %cond_19_case_0
  %"014.0" = phi { ptr, ptr, i64 } [ zeroinitializer, %cond_19_case_0 ], [ %38, %cond_19_case_1 ]
  %array_ptr26 = extractvalue { ptr, ptr, i64 } %"014.0", 0
  %array_mask_ptr27 = extractvalue { ptr, ptr, i64 } %"014.0", 1
  %array_offset28 = extractvalue { ptr, ptr, i64 } %"014.0", 2
  %42 = icmp ult i64 0, 2
  br i1 %42, label %44, label %43

43:                                               ; preds = %cond_exit_19
  br label %49

44:                                               ; preds = %cond_exit_19
  %45 = add i64 0, %array_offset28
  call void @__barray_mask_check_not_borrowed(ptr %array_mask_ptr27, i64 %45)
  %46 = getelementptr inbounds i64, ptr %array_ptr26, i64 %45
  %47 = load i64, ptr %46, align 4
  %48 = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %47, 1
  br label %49

49:                                               ; preds = %43, %44
  %"029.0" = phi { i1, i64 } [ %48, %44 ], [ { i1 false, i64 poison }, %43 ]
  %50 = extractvalue { i1, i64 } %"029.0", 0
  switch i1 %50, label %51 [
    i1 true, label %52
  ]

51:                                               ; preds = %49
  br label %cond_31_case_0

52:                                               ; preds = %49
  %53 = extractvalue { i1, i64 } %"029.0", 1
  br label %cond_31_case_1

cond_31_case_0:                                   ; preds = %51
  %54 = extractvalue { i32, ptr } { i32 1, ptr @2 }, 0
  %55 = extractvalue { i32, ptr } { i32 1, ptr @2 }, 1
  %56 = call i32 (ptr, ...) @printf(ptr @prelude.panic_template.2, i32 %54, ptr %55)
  call void @abort()
  br label %cond_exit_31

cond_31_case_1:                                   ; preds = %52
  br label %cond_exit_31

cond_exit_31:                                     ; preds = %cond_31_case_1, %cond_31_case_0
  %"033.0" = phi i64 [ 0, %cond_31_case_0 ], [ %53, %cond_31_case_1 ]
  %array_ptr43 = extractvalue { ptr, ptr, i64 } %"014.0", 0
  %array_mask_ptr44 = extractvalue { ptr, ptr, i64 } %"014.0", 1
  %array_offset45 = extractvalue { ptr, ptr, i64 } %"014.0", 2
  %57 = icmp ult i64 1, 2
  br i1 %57, label %61, label %58

58:                                               ; preds = %cond_exit_31
  %59 = insertvalue { i1, { ptr, ptr, i64 }, i64 } { i1 false, { ptr, ptr, i64 } poison, i64 poison }, i64 %"033.0", 2
  %60 = insertvalue { i1, { ptr, ptr, i64 }, i64 } %59, { ptr, ptr, i64 } %"014.0", 1
  br label %67

61:                                               ; preds = %cond_exit_31
  %62 = add i64 1, %array_offset45
  call void @__barray_mask_check_not_borrowed(ptr %array_mask_ptr44, i64 %62)
  %63 = getelementptr inbounds i64, ptr %array_ptr43, i64 %62
  %64 = load i64, ptr %63, align 4
  store i64 %"033.0", ptr %63, align 4
  %65 = insertvalue { i1, { ptr, ptr, i64 }, i64 } { i1 true, { ptr, ptr, i64 } poison, i64 poison }, i64 %64, 2
  %66 = insertvalue { i1, { ptr, ptr, i64 }, i64 } %65, { ptr, ptr, i64 } %"014.0", 1
  br label %67

67:                                               ; preds = %58, %61
  %"046.0" = phi { i1, { ptr, ptr, i64 }, i64 } [ %66, %61 ], [ %60, %58 ]
  %68 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %"046.0", 0
  switch i1 %68, label %69 [
    i1 true, label %72
  ]

69:                                               ; preds = %67
  %70 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %"046.0", 2
  %71 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %"046.0", 1
  br label %cond_42_case_0

72:                                               ; preds = %67
  %73 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %"046.0", 2
  %74 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %"046.0", 1
  br label %cond_42_case_1

cond_42_case_0:                                   ; preds = %69
  %75 = extractvalue { i32, ptr } { i32 1, ptr @3 }, 0
  %76 = extractvalue { i32, ptr } { i32 1, ptr @3 }, 1
  %77 = call i32 (ptr, ...) @printf(ptr @prelude.panic_template.3, i32 %75, ptr %76)
  call void @abort()
  br label %cond_exit_42

cond_42_case_1:                                   ; preds = %72
  br label %cond_exit_42

cond_exit_42:                                     ; preds = %cond_42_case_1, %cond_42_case_0
  %"049.0" = phi i64 [ 0, %cond_42_case_0 ], [ %73, %cond_42_case_1 ]
  %"150.0" = phi { ptr, ptr, i64 } [ zeroinitializer, %cond_42_case_0 ], [ %74, %cond_42_case_1 ]
  %array_ptr69 = extractvalue { ptr, ptr, i64 } %"150.0", 0
  %array_mask_ptr70 = extractvalue { ptr, ptr, i64 } %"150.0", 1
  %array_offset71 = extractvalue { ptr, ptr, i64 } %"150.0", 2
  %new_offset = add i64 %array_offset71, 1
  call void @__barray_mask_check_not_borrowed(ptr %array_mask_ptr70, i64 %array_offset71)
  %78 = getelementptr inbounds i64, ptr %array_ptr69, i64 %array_offset71
  %79 = load i64, ptr %78, align 4
  %80 = insertvalue { ptr, ptr, i64 } poison, ptr %array_ptr69, 0
  %81 = insertvalue { ptr, ptr, i64 } %80, ptr %array_mask_ptr70, 1
  %82 = insertvalue { ptr, ptr, i64 } %81, i64 %new_offset, 2
  %83 = insertvalue { i1, { ptr, ptr, i64 }, i64 } { i1 true, { ptr, ptr, i64 } poison, i64 poison }, i64 %79, 2
  %84 = insertvalue { i1, { ptr, ptr, i64 }, i64 } %83, { ptr, ptr, i64 } %82, 1
  %85 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %84, 0
  switch i1 %85, label %86 [
    i1 true, label %87
  ]

86:                                               ; preds = %cond_exit_42
  br label %cond_53_case_0

87:                                               ; preds = %cond_exit_42
  %88 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %84, 2
  %89 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %84, 1
  br label %cond_53_case_1

cond_53_case_0:                                   ; preds = %86
  %90 = extractvalue { i32, ptr } { i32 1, ptr @4 }, 0
  %91 = extractvalue { i32, ptr } { i32 1, ptr @4 }, 1
  %92 = call i32 (ptr, ...) @printf(ptr @prelude.panic_template.4, i32 %90, ptr %91)
  call void @abort()
  br label %cond_exit_53

cond_53_case_1:                                   ; preds = %87
  br label %cond_exit_53

cond_exit_53:                                     ; preds = %cond_53_case_1, %cond_53_case_0
  %"073.0" = phi i64 [ 0, %cond_53_case_0 ], [ %88, %cond_53_case_1 ]
  %"174.0" = phi { ptr, ptr, i64 } [ zeroinitializer, %cond_53_case_0 ], [ %89, %cond_53_case_1 ]
  %array_ptr87 = extractvalue { ptr, ptr, i64 } %"174.0", 0
  %array_mask_ptr88 = extractvalue { ptr, ptr, i64 } %"174.0", 1
  %array_offset89 = extractvalue { ptr, ptr, i64 } %"174.0", 2
  %93 = add i64 %array_offset89, 0
  call void @__barray_mask_check_not_borrowed(ptr %array_mask_ptr88, i64 %93)
  %94 = getelementptr inbounds i64, ptr %array_ptr87, i64 %93
  %95 = load i64, ptr %94, align 4
  %96 = insertvalue { ptr, ptr, i64 } poison, ptr %array_ptr87, 0
  %97 = insertvalue { ptr, ptr, i64 } %96, ptr %array_mask_ptr88, 1
  %98 = insertvalue { ptr, ptr, i64 } %97, i64 %array_offset89, 2
  %99 = insertvalue { i1, { ptr, ptr, i64 }, i64 } { i1 true, { ptr, ptr, i64 } poison, i64 poison }, i64 %95, 2
  %100 = insertvalue { i1, { ptr, ptr, i64 }, i64 } %99, { ptr, ptr, i64 } %98, 1
  %101 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %100, 0
  switch i1 %101, label %102 [
    i1 true, label %103
  ]

102:                                              ; preds = %cond_exit_53
  br label %cond_64_case_0

103:                                              ; preds = %cond_exit_53
  %104 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %100, 2
  %105 = extractvalue { i1, { ptr, ptr, i64 }, i64 } %100, 1
  br label %cond_64_case_1

cond_64_case_0:                                   ; preds = %102
  %106 = extractvalue { i32, ptr } { i32 1, ptr @5 }, 0
  %107 = extractvalue { i32, ptr } { i32 1, ptr @5 }, 1
  %108 = call i32 (ptr, ...) @printf(ptr @prelude.panic_template.5, i32 %106, ptr %107)
  call void @abort()
  br label %cond_exit_64

cond_64_case_1:                                   ; preds = %103
  br label %cond_exit_64

cond_exit_64:                                     ; preds = %cond_64_case_1, %cond_64_case_0
  %"091.0" = phi i64 [ 0, %cond_64_case_0 ], [ %104, %cond_64_case_1 ]
  %"192.0" = phi { ptr, ptr, i64 } [ zeroinitializer, %cond_64_case_0 ], [ %105, %cond_64_case_1 ]
  %array_ptr105 = extractvalue { ptr, ptr, i64 } %"192.0", 0
  %array_mask_ptr106 = extractvalue { ptr, ptr, i64 } %"192.0", 1
  %array_offset107 = extractvalue { ptr, ptr, i64 } %"192.0", 2
  call void @free(ptr %array_ptr105)
  call void @free(ptr %array_mask_ptr106)
  ret void
}

declare ptr @malloc(i64)

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0

define internal void @__barray_mask_check_not_borrowed(ptr %0, i64 %1) {
  %3 = udiv i64 %1, 64
  %4 = getelementptr inbounds i64, ptr %0, i64 %3
  %5 = load i64, ptr %4, align 4
  %6 = urem i64 %1, 64
  %7 = lshr i64 %5, %6
  %8 = trunc i64 %7 to i1
  br i1 %8, label %panic, label %ok

panic:                                            ; preds = %2
  %9 = call i32 (ptr, ...) @printf(ptr @prelude.panic_template, i32 2, ptr @0)
  call void @abort()
  unreachable

ok:                                               ; preds = %2
  ret void
}

declare i32 @printf(ptr, ...)

declare void @abort()

declare void @free(ptr)

attributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }
