//! Builders and utilities for benchmarks.

use std::sync::Arc;

use hugr::builder::{
    BuildError, CFGBuilder, Container, DFGBuilder, Dataflow, DataflowHugr, DataflowSubContainer,
    HugrBuilder, ModuleBuilder,
};
use hugr::extension::prelude::{BOOL_T, QB_T, USIZE_T};
use hugr::extension::PRELUDE_REGISTRY;
use hugr::ops::OpName;
use hugr::std_extensions::arithmetic::float_ops::FLOAT_OPS_REGISTRY;
use hugr::std_extensions::arithmetic::float_types::FLOAT64_TYPE;
use hugr::types::Signature;
use hugr::{type_row, Extension, Hugr, Node};
use lazy_static::lazy_static;

pub fn simple_dfg_hugr() -> Hugr {
    let dfg_builder =
        DFGBuilder::new(Signature::new(type_row![BOOL_T], type_row![BOOL_T])).unwrap();
    let [i1] = dfg_builder.input_wires_arr();
    dfg_builder.finish_prelude_hugr_with_outputs([i1]).unwrap()
}

pub fn simple_cfg_builder<T: AsMut<Hugr> + AsRef<Hugr>>(
    cfg_builder: &mut CFGBuilder<T>,
) -> Result<(), BuildError> {
    let sum2_variants = vec![type_row![USIZE_T], type_row![USIZE_T]];
    let mut entry_b = cfg_builder.entry_builder(sum2_variants.clone(), type_row![])?;
    let entry = {
        let [inw] = entry_b.input_wires_arr();

        let sum = entry_b.make_sum(1, sum2_variants, [inw])?;
        entry_b.finish_with_outputs(sum, [])?
    };
    let mut middle_b = cfg_builder
        .simple_block_builder(Signature::new(type_row![USIZE_T], type_row![USIZE_T]), 1)?;
    let middle = {
        let c = middle_b.add_load_const(hugr::ops::Value::unary_unit_sum());
        let [inw] = middle_b.input_wires_arr();
        middle_b.finish_with_outputs(c, [inw])?
    };
    let exit = cfg_builder.exit_block();
    cfg_builder.branch(&entry, 0, &middle)?;
    cfg_builder.branch(&middle, 0, &exit)?;
    cfg_builder.branch(&entry, 1, &exit)?;
    Ok(())
}

pub fn simple_cfg_hugr() -> Hugr {
    let mut cfg_builder =
        CFGBuilder::new(Signature::new(type_row![USIZE_T], type_row![USIZE_T])).unwrap();
    simple_cfg_builder(&mut cfg_builder).unwrap();
    cfg_builder.finish_prelude_hugr().unwrap()
}

lazy_static! {
    static ref QUANTUM_EXT: Arc<Extension> = {
        Extension::new_arc(
            "bench.quantum".try_into().unwrap(),
            hugr::extension::Version::new(0, 0, 0),
            |ext, extension_ref| {
                ext.add_op(
                    OpName::new_inline("H"),
                    "".into(),
                    Signature::new_endo(QB_T),
                    extension_ref,
                )
                .unwrap();
                ext.add_op(
                    OpName::new_inline("Rz"),
                    "".into(),
                    Signature::new(type_row![QB_T, FLOAT64_TYPE], type_row![QB_T]),
                    extension_ref,
                )
                .unwrap();

                ext.add_op(
                    OpName::new_inline("CX"),
                    "".into(),
                    Signature::new_endo(type_row![QB_T, QB_T]),
                    extension_ref,
                )
                .unwrap();
            },
        )
    };
}

/// The node ids for a layer generated by the [`circuit`] function.
pub struct CircuitLayer {
    pub h: Node,
    pub cx1: Node,
    pub cx2: Node,
}

/// Construct a quantum circuit with two qubits and `layers` layers applying `H q0; CX q0, q1; CX q1, q0`.
pub fn circuit(layers: usize) -> (Hugr, Vec<CircuitLayer>) {
    let h_gate = QUANTUM_EXT
        .instantiate_extension_op("H", [], &PRELUDE_REGISTRY)
        .unwrap();
    let cx_gate = QUANTUM_EXT
        .instantiate_extension_op("CX", [], &PRELUDE_REGISTRY)
        .unwrap();
    // let rz = QUANTUM_EXT
    //     .instantiate_extension_op("Rz", [], &FLOAT_OPS_REGISTRY)
    //     .unwrap();
    let signature =
        Signature::new_endo(type_row![QB_T, QB_T]).with_extension_delta(QUANTUM_EXT.name().clone());
    let mut module_builder = ModuleBuilder::new();
    let mut f_build = module_builder.define_function("main", signature).unwrap();

    let wires: Vec<_> = f_build.input_wires().collect();

    let mut linear = f_build.as_circuit(wires);

    let mut layer_ids = Vec::with_capacity(layers);
    for _ in 0..layers {
        linear.append(h_gate.clone(), [0]).unwrap();
        let h = linear.tracked_wire(0).unwrap().node();
        linear.append(cx_gate.clone(), [0, 1]).unwrap();
        let cx1 = linear.tracked_wire(0).unwrap().node();
        linear.append(cx_gate.clone(), [1, 0]).unwrap();
        let cx2 = linear.tracked_wire(0).unwrap().node();

        // TODO: Currently left out because we can not represent constants in the model
        // let angle = linear.add_constant(ConstF64::new(0.5));
        // linear
        //     .append_and_consume(
        //         rz.clone(),
        //         [CircuitUnit::Linear(0), CircuitUnit::Wire(angle)],
        //     )
        //     .unwrap();

        layer_ids.push(CircuitLayer { h, cx1, cx2 });
    }

    let outs = linear.finish();
    f_build.finish_with_outputs(outs).unwrap();

    (
        module_builder.finish_hugr(&FLOAT_OPS_REGISTRY).unwrap(),
        layer_ids,
    )
}
