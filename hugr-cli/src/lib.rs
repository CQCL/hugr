//! Standard command line tools for the HUGR format.
//!
//! This library provides utilities for the HUGR CLI.
//!
//! ## CLI Usage
//!
//! Run `cargo install hugr-cli` to install the CLI tools. This will make the
//! `hugr` executable available in your shell as long as you have [cargo's bin
//! directory](https://doc.rust-lang.org/book/ch14-04-installing-binaries.html)
//! in your path.
//!
//! The top level help can be accessed with:
//! ```sh
//! hugr --help
//! ```
//!
//! Refer to the help for each subcommand for more information, e.g.
//! ```sh
//! hugr validate --help
//! ```

use std::ffi::OsString;

use anyhow::Result;
use clap::{Parser, crate_version};
use clap_verbosity_flag::VerbosityFilter;
use clap_verbosity_flag::{InfoLevel, Verbosity};
use hugr::envelope::EnvelopeError;
use hugr::package::PackageValidationError;
use thiserror::Error;
use tracing::{error, metadata::LevelFilter};

pub mod convert;
pub mod describe;
pub mod extensions;
pub mod hugr_io;
pub mod mermaid;
pub mod validate;

/// CLI arguments.
#[derive(Parser, Debug)]
#[clap(version = crate_version!(), long_about = None)]
#[clap(about = "HUGR CLI tools.")]
#[group(id = "hugr")]
pub struct CliArgs {
    /// The command to be run.
    #[command(subcommand)]
    pub command: CliCommand,
    /// Verbosity.
    #[command(flatten)]
    pub verbose: Verbosity<InfoLevel>,
}

/// The CLI subcommands.
#[derive(Debug, clap::Subcommand)]
#[non_exhaustive]
pub enum CliCommand {
    /// Validate a HUGR package.
    Validate(validate::ValArgs),
    /// Write standard extensions out in serialized form.
    GenExtensions(extensions::ExtArgs),
    /// Write HUGR as mermaid diagrams.
    Mermaid(mermaid::MermaidArgs),
    /// Convert between different HUGR envelope formats.
    Convert(convert::ConvertArgs),
    /// External commands
    #[command(external_subcommand)]
    External(Vec<OsString>),

    /// Describe the contents of a HUGR package.
    ///
    /// If an error occurs during loading partial descriptions are printed.
    /// For example if the first module is loaded and the second fails then
    /// only the first module will be described.
    Describe(describe::DescribeArgs),
}

/// Error type for the CLI.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum CliError {
    /// Error reading input.
    #[error("Error reading from path.")]
    InputFile(#[from] std::io::Error),
    /// Error parsing input.
    #[error("Error parsing package.")]
    Parse(#[from] serde_json::Error),
    #[error("Error validating HUGR.")]
    /// Errors produced by the `validate` subcommand.
    Validate(#[from] PackageValidationError),
    #[error("Error decoding HUGR envelope.")]
    /// Errors produced by the `validate` subcommand.
    Envelope(#[from] EnvelopeError),
    /// Pretty error when the user passes a non-envelope file.
    #[error(
        "Input file is not a HUGR envelope. Invalid magic number.\n\nUse `--hugr-json` to read a raw HUGR JSON file instead."
    )]
    NotAnEnvelope,
    /// Invalid format string for conversion.
    #[error(
        "Invalid format: '{_0}'. Valid formats are: json, model, model-exts, model-text, model-text-exts"
    )]
    InvalidFormat(String),
    #[error("Error validating HUGR generated by {generator}")]
    /// Errors produced by the `validate` subcommand, with a known generator of the HUGR.
    ValidateKnownGenerator {
        #[source]
        /// The inner validation error.
        inner: PackageValidationError,
        /// The generator of the HUGR.
        generator: Box<String>,
    },
    #[error("Error reading envelope.")]
    /// Errors produced when reading an envelope.
    ReadEnvelope(#[from] hugr::envelope::ReadError),
}

impl CliError {
    /// Returns a validation error, with an optional generator.
    pub fn validation(generator: Option<String>, val_err: PackageValidationError) -> Self {
        if let Some(g) = generator {
            Self::ValidateKnownGenerator {
                inner: val_err,
                generator: Box::new(g.to_string()),
            }
        } else {
            Self::Validate(val_err)
        }
    }
}

impl Default for CliArgs {
    fn default() -> Self {
        Self::new()
    }
}

impl CliArgs {
    /// Parse CLI arguments from the environment.
    pub fn new() -> Self {
        CliArgs::parse()
    }

    /// Parse CLI arguments from an iterator.
    pub fn new_from_args<I, T>(args: I) -> Self
    where
        I: IntoIterator<Item = T>,
        T: Into<std::ffi::OsString> + Clone,
    {
        CliArgs::parse_from(args)
    }

    /// Entrypoint for cli - process arguments and run commands.
    pub fn run(self) {
        let level = match self.verbose.filter() {
            VerbosityFilter::Off => LevelFilter::OFF,
            VerbosityFilter::Error => LevelFilter::ERROR,
            VerbosityFilter::Warn => LevelFilter::WARN,
            VerbosityFilter::Info => LevelFilter::INFO,
            VerbosityFilter::Debug => LevelFilter::DEBUG,
            VerbosityFilter::Trace => LevelFilter::TRACE,
        };
        tracing_subscriber::fmt()
            .with_writer(std::io::stderr)
            .with_max_level(level)
            .pretty()
            .init();

        let result = match self.command {
            CliCommand::Validate(mut args) => args.run(),
            CliCommand::GenExtensions(args) => args.run_dump(&hugr::std_extensions::STD_REG),
            CliCommand::Mermaid(mut args) => args.run_print(),
            CliCommand::Convert(mut args) => args.run_convert(),
            CliCommand::Describe(mut args) => args.run_describe(),
            CliCommand::External(args) => run_external(args),
        };

        if let Err(err) = result {
            error!("{:?}", err);
            std::process::exit(1);
        }
    }
}

fn run_external(args: Vec<OsString>) -> Result<()> {
    // External subcommand support: invoke `hugr-<subcommand>`
    if args.is_empty() {
        eprintln!("No external subcommand specified.");
        std::process::exit(1);
    }
    let subcmd = args[0].to_string_lossy();
    let exe = format!("hugr-{subcmd}");
    let rest: Vec<_> = args[1..]
        .iter()
        .map(|s| s.to_string_lossy().to_string())
        .collect();
    match std::process::Command::new(&exe).args(&rest).status() {
        Ok(status) => {
            if !status.success() {
                std::process::exit(status.code().unwrap_or(1));
            }
        }
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            eprintln!("error: no such subcommand: '{subcmd}'.\nCould not find '{exe}' in PATH.");
            std::process::exit(1);
        }
        Err(e) => {
            eprintln!("error: failed to invoke '{exe}': {e}");
            std::process::exit(1);
        }
    }

    Ok(())
}

impl CliArgs {
    /// Run a CLI command with bytes input and capture bytes output.
    ///
    /// This provides a programmatic interface to the CLI, useful for
    /// language bindings (e.g., Python via PyO3). Unlike `run()`, this
    /// method:
    /// - Accepts input as a byte slice instead of reading from stdin/files
    /// - Returns output as a byte vector instead of writing to stdout/files
    /// - Still writes logs and errors to stderr as normal
    ///
    /// # Arguments
    ///
    /// * `input` - The input data as bytes (e.g., a HUGR package)
    ///
    /// # Returns
    ///
    /// Returns `Ok(Vec<u8>)` with the command output, or `Err(CliError)` on failure.
    ///
    /// # Note
    ///
    /// Currently only the `validate` command is supported. Other commands will
    /// return an error. The `gen-extensions` command doesn't require input and
    /// should use the normal `run()` method instead.
    pub fn run_with_bytes(mut self, input: &[u8]) -> Result<Vec<u8>> {
        use std::io::Cursor;

        match self.command {
            CliCommand::Validate(ref mut args) => {
                // Run validation with the bytes input
                args.run_with_input(Some(Cursor::new(input)))?;
                // Validate has no output, return empty vec
                Ok(Vec::new())
            }
            x => Err(anyhow::anyhow!(
                "This command does not support programmatic byte input/output yet {x:?}"
            )),
        }
    }
}
